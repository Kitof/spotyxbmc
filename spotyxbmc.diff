Index: xbmc/XBApplicationEx.cpp
===================================================================
--- xbmc/XBApplicationEx.cpp	(revision 27356)
+++ xbmc/XBApplicationEx.cpp	(working copy)
@@ -21,6 +21,9 @@
 #include "system.h"
 #include "XBApplicationEx.h"
 #include "utils/log.h"
+//spotify
+#include "spotinterface.h"
+#include "AdvancedSettings.h"
 #ifdef HAS_PERFORMANCE_SAMPLE
 #include "utils/PerformanceSample.h"
 #else
@@ -86,6 +89,17 @@
     try
     {
 #endif
+ //spotify, advance the spotifyAPI
+      if (g_advancedSettings.m_spotifyEnable)
+      {
+          try
+          {
+             g_spotifyInterface->processEvents();
+          }catch (...)
+          {
+              CLog::Log(LOGERROR, "Spotifylog: sp_session_process_events, did throw an exception");
+          }
+      }
       Process();
       //reset exception count
       processExceptionCount = 0;
Index: xbmc/GUIViewState.cpp
===================================================================
--- xbmc/GUIViewState.cpp	(revision 27356)
+++ xbmc/GUIViewState.cpp	(working copy)
@@ -59,6 +59,10 @@
 
   if (url.GetProtocol()=="musicsearch")
     return new CGUIViewStateMusicSearch(items);
+  
+  //spotify
+  if (url.GetProtocol()=="spotify")
+    return new CGUIViewStateSpotifyLibrary(items);
 
   if (items.IsSmartPlayList())
   {
Index: xbmc/cores/paplayer/Makefile.in
===================================================================
--- xbmc/cores/paplayer/Makefile.in	(revision 27356)
+++ xbmc/cores/paplayer/Makefile.in	(working copy)
@@ -9,7 +9,7 @@
 
 CFLAGS+=-DHAS_ALSA
 
-SRCS=AC3CDDACodec.cpp AC3Codec.cpp ADPCMCodec.cpp AIFFcodec.cpp AudioDecoder.cpp CDDAcodec.cpp CodecFactory.cpp VGMCodec.cpp FLACcodec.cpp GYMCodec.cpp MP3codec.cpp NSFCodec.cpp OGGcodec.cpp ReplayGain.cpp SIDCodec.cpp TimidityCodec.cpp WAVcodec.cpp WAVPackcodec.cpp YMCodec.cpp DVDPlayerCodec.cpp DTSCodec.cpp DTSCDDACodec.cpp PAPlayer.cpp OggCallback.cpp ModplugCodec.cpp
+SRCS=spotifyCodec.cpp AC3CDDACodec.cpp AC3Codec.cpp ADPCMCodec.cpp AIFFcodec.cpp AudioDecoder.cpp CDDAcodec.cpp CodecFactory.cpp VGMCodec.cpp FLACcodec.cpp GYMCodec.cpp MP3codec.cpp NSFCodec.cpp OGGcodec.cpp ReplayGain.cpp SIDCodec.cpp TimidityCodec.cpp WAVcodec.cpp WAVPackcodec.cpp YMCodec.cpp DVDPlayerCodec.cpp DTSCodec.cpp DTSCDDACodec.cpp PAPlayer.cpp OggCallback.cpp ModplugCodec.cpp
 
 ifeq (@USE_ASAP_CODEC@,1)
   SRCS+=ASAPCodec.cpp
Index: xbmc/cores/paplayer/CodecFactory.cpp
===================================================================
--- xbmc/cores/paplayer/CodecFactory.cpp	(revision 27356)
+++ xbmc/cores/paplayer/CodecFactory.cpp	(working copy)
@@ -20,6 +20,9 @@
  */
 
 #include "system.h"
+//spotify
+#include "spotifyCodec.h"
+
 #include "XBAudioConfig.h"
 #include "CodecFactory.h"
 #include "MP3codec.h"
@@ -54,7 +57,10 @@
 
 ICodec* CodecFactory::CreateCodec(const CStdString& strFileType)
 {
-  if (strFileType.Equals("mp3") || strFileType.Equals("mp2"))
+  //spotify
+  if (strFileType.Equals("spotify"))
+    return new SpotifyCodec();
+  else if (strFileType.Equals("mp3") || strFileType.Equals("mp2"))
     return new MP3Codec();
   else if (strFileType.Equals("ape") || strFileType.Equals("mac"))
     return new DVDPlayerCodec();
Index: xbmc/cores/paplayer/PAPlayer.cpp
===================================================================
--- xbmc/cores/paplayer/PAPlayer.cpp	(revision 27356)
+++ xbmc/cores/paplayer/PAPlayer.cpp	(working copy)
@@ -33,6 +33,8 @@
 #include "../AudioRenderers/AudioRendererFactory.h"
 #include "../../utils/TimeUtils.h"
 #include "utils/log.h"
+//spotify
+#include "spotinterface.h"
 
 #ifdef _LINUX
 #define XBMC_SAMPLE_RATE 44100
@@ -536,7 +538,13 @@
     UpdateCacheLevel();
 
     // check whether we should queue the next file up
-    if ((GetTotalTime64() > 0) && GetTotalTime64() - GetTime() < TIME_TO_CACHE_NEXT_FILE + m_crossFading * 1000L && !m_cachingNextFile)
+    //spotify, we can only get the new file if the old one is done reading
+    bool isSpotifyFree = true;
+    if (m_decoder[m_currentDecoder].GetCodec()->m_CodecName == "spotify")
+    {
+       isSpotifyFree = g_spotifyInterface->spotifyPlayerIsFree();
+    }
+    if (isSpotifyFree && (GetTotalTime64() > 0) && GetTotalTime64() - GetTime() < TIME_TO_CACHE_NEXT_FILE + m_crossFading * 1000L && !m_cachingNextFile)
     { // request the next file from our application
       m_callback.OnQueueNextItem();
       m_cachingNextFile = true;
Index: xbmc/Application.cpp
===================================================================
--- xbmc/Application.cpp	(revision 27356)
+++ xbmc/Application.cpp	(working copy)
@@ -23,6 +23,9 @@
   #include "config.h"
 #endif
 #include "Application.h"
+//spotify
+#include "spotinterface.h"
+
 #include "utils/Builtins.h"
 #include "Splash.h"
 #include "KeyboardLayoutConfiguration.h"
@@ -350,6 +353,12 @@
 
 CApplication::~CApplication(void)
 {
+  //spotify
+  if (g_advancedSettings.m_spotifyEnable)
+  {
+      delete g_spotifyInterface;
+  }
+  g_spotifyInterface = 0;
   delete m_currentStack;
 
 #ifdef HAS_KARAOKE
@@ -1266,6 +1275,13 @@
     g_windowManager.ActivateWindow(startWindow);
   }
 
+  //spotify
+  if (g_advancedSettings.m_spotifyEnable)
+  {
+      g_spotifyInterface = new SpotifyInterface;
+      g_spotifyInterface->connect(false);
+  }
+
 #ifdef HAS_PYTHON
   g_pythonParser.m_bStartup = true;
 #endif
Index: xbmc/AdvancedSettings.cpp
===================================================================
--- xbmc/AdvancedSettings.cpp	(revision 27356)
+++ xbmc/AdvancedSettings.cpp	(working copy)
@@ -60,6 +60,16 @@
   m_karaokeAlwaysEmptyOnCdgs = 1;
   m_karaokeUseSongSpecificBackground = 0;
 
+  //spotify
+  m_spotifyEnable = true;
+  m_spotifyUseHighBitrate = true;
+  m_spotifyUsername = "";
+  m_spotifyPassword = "";
+  m_spotifyCacheFolder = "/tmp/spotify/";
+  m_spotifyMaxSearchArtists = 50;
+  m_spotifyMaxSearchAlbums = 50;
+  m_spotifyMaxSearchTracks = 100;
+
   m_audioDefaultPlayer = "paplayer";
   m_audioPlayCountMinimumPercent = 90.0f;
   m_audioHost = "default";
@@ -543,6 +553,20 @@
     XMLUtils::GetInt(pElement, "movielength", m_iMythMovieLength);
   }
 
+  //spotify
+  pElement = pRootElement->FirstChildElement("spotify");
+  if (pElement)
+  {
+    XMLUtils::GetBoolean(pElement, "enable", m_spotifyEnable);
+    XMLUtils::GetBoolean(pElement, "highbitrate", m_spotifyUseHighBitrate);
+    XMLUtils::GetString(pElement, "username", m_spotifyUsername);
+    XMLUtils::GetString(pElement, "password", m_spotifyPassword);
+    XMLUtils::GetString(pElement, "cachefolder", m_spotifyCacheFolder);
+    XMLUtils::GetInt(pElement, "maxsearchartists", m_spotifyMaxSearchArtists, 0, 500);
+    XMLUtils::GetInt(pElement, "maxsearchalbums", m_spotifyMaxSearchAlbums,0,500);
+    XMLUtils::GetInt(pElement, "maxsearchtracks", m_spotifyMaxSearchTracks,0,1000);
+  }
+
   // EDL commercial break handling
   pElement = pRootElement->FirstChildElement("edl");
   if (pElement)
Index: xbmc/MusicDatabase.h
===================================================================
--- xbmc/MusicDatabase.h	(revision 27356)
+++ xbmc/MusicDatabase.h	(working copy)
@@ -116,6 +116,10 @@
   void EmptyCache();
   void Clean();
   int  Cleanup(CGUIDialogProgress *pDlgProgress);
+
+  //spotify, we need a new function to remove albums from the database
+  bool RemoveAlbum(CStdString albumPath);
+
   void DeleteAlbumInfo();
   bool LookupCDDBInfo(bool bRequery=false);
   void DeleteCDDBInfo();
Index: xbmc/FileSystem/Makefile.in
===================================================================
--- xbmc/FileSystem/Makefile.in	(revision 27356)
+++ xbmc/FileSystem/Makefile.in	(working copy)
@@ -8,7 +8,8 @@
 
 CXXFLAGS+=-D__STDC_FORMAT_MACROS \
 
-SRCS=ASAPFileDirectory.cpp \
+SRCS=SpotifyDirectory.cpp \
+     ASAPFileDirectory.cpp \
      CacheMemBuffer.cpp \
      CacheStrategy.cpp \
      CDDADirectory.cpp \
Index: xbmc/FileSystem/MusicDatabaseDirectory.cpp
===================================================================
--- xbmc/FileSystem/MusicDatabaseDirectory.cpp	(revision 27356)
+++ xbmc/FileSystem/MusicDatabaseDirectory.cpp	(working copy)
@@ -29,6 +29,9 @@
 #include "TextureManager.h"
 #include "LocalizeStrings.h"
 #include "utils/log.h"
+//spotify
+#include "spotinterface.h"
+#include "MusicInfoTag.h"
 
 using namespace std;
 using namespace XFILE;
@@ -44,270 +47,373 @@
 
 bool CMusicDatabaseDirectory::GetDirectory(const CStdString& strPath, CFileItemList &items)
 {
-  auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
+    //artistbrowsing
+    if (strPath.Left(33) == "musicdb://3/spotifyartist/albums/")
+    {
+        return g_spotifyInterface->getBrowseArtistAlbums(strPath.c_str(), items);
+    }
 
-  if (!pNode.get())
-    return false;
+    else if (strPath.Left(34) == "musicdb://1/spotifyartist/artists/")
+    {
+        return g_spotifyInterface->getBrowseArtistArtists(strPath.c_str(), items);
+    }
 
-  bool bResult = pNode->GetChilds(items);
-  for (int i=0;i<items.Size();++i)
-  {
-    CFileItemPtr item = items[i];
-    if (item->m_bIsFolder && !item->HasIcon() && !item->HasThumbnail())
+    else if (strPath.Left(26) == "musicdb://1/spotifyartist/")
     {
-      CStdString strImage = GetIcon(item->m_strPath);
-      if (!strImage.IsEmpty() && g_TextureManager.HasTexture(strImage))
-        item->SetIconImage(strImage);
+        return g_spotifyInterface->getBrowseArtistMenu(strPath.c_str(), items);
     }
-  }
 
-  return bResult;
+    //and if its a spotify album
+    else if (strPath.Left(25) == "musicdb://2/spotifyalbum/")
+    {
+        //if (g_spotifyInterface->isBrowsingAlbum())
+        //{
+            CLog::Log(LOGWARNING, "Spotifylog: loading spotify tracks from albumbrowse");
+            g_spotifyInterface->getBrowseAlbumTracks(strPath,items);
+            if (items.IsEmpty())
+            {
+                //return and wait for the callback
+                return true;
+            }
+            //and we want a link so we can save the album to our library, if its not allready there
+            CMusicDatabase *musicdatabase = new CMusicDatabase;
+            musicdatabase->Open();
+            MUSIC_INFO::CMusicInfoTag *tag = items.Get(0)->GetMusicInfoTag();
+            int albumId = musicdatabase->GetAlbumByName(tag->GetAlbum());
+            if (albumId == -1)
+            {
+                MUSIC_INFO::CMusicInfoTag *tag = items[0]->GetMusicInfoTag();
+                CAlbum album;
+                album.iYear = tag->GetYear();
+                album.strArtist = tag->GetAlbumArtist();
+                album.strAlbum = tag->GetAlbum();
+                CFileItemPtr pItem(new CFileItem("spotify://addalbum",album));
+                pItem->m_strPath = "spotify://addalbum";
+                pItem->m_strTitle = "Add album to library";
+                pItem->SetLabel("Add album to library");
+                pItem->SetThumbnailImage(items[0]->GetThumbnailImage());
+                items.Add(pItem);
+            }
+            musicdatabase->Close();
+            delete musicdatabase;
+            return true;
+    }
+
+    //if we are getting results from a spotify search
+    else if (strPath.Left(33) == "musicdb://1/spotifysearchartist/")
+    {
+        CLog::Log(LOGWARNING, "Spotifylog: loading spotify artists from search");
+        g_spotifyInterface->getSearchArtists(items);
+        if (items.IsEmpty())
+            return false;
+        return true;
+    }
+
+    else if (strPath.Left(32) == "musicdb://2/spotifysearchalbums/")
+    {
+        CLog::Log(LOGWARNING, "Spotifylog: loading spotify albums from search");
+        g_spotifyInterface->getSearchAlbums(items);
+        if (items.IsEmpty())
+            return false;
+        return true;
+    }
+
+    else if (strPath.Left(32) == "musicdb://3/spotifysearchtracks/")
+    {
+        CLog::Log(LOGWARNING, "Spotifylog: loading spotify tracks from search");
+        g_spotifyInterface->getSearchTracks(items);
+        if (items.IsEmpty())
+            return false;
+        return true;
+    }
+
+    //maby we want to load tracks from a playlist
+    else if (strPath.Left(28) == "musicdb://2/spotifyplaylist/")
+    {
+        CStdString playListNr = strPath;
+        playListNr.Delete(0, 28);
+        CUtil::RemoveSlashAtEnd(playListNr);
+        g_spotifyInterface->getPlaylistTracks(items,atoi(playListNr.c_str()));
+        if (items.IsEmpty())
+            return false;
+        return true;
+    }
+    else
+    {
+        auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
+
+        if (!pNode.get())
+            return false;
+
+        bool bResult = pNode->GetChilds(items);
+        for (int i=0;i<items.Size();++i)
+        {
+            CFileItemPtr item = items[i];
+            if (item->m_bIsFolder && !item->HasIcon() && !item->HasThumbnail())
+            {
+                CStdString strImage = GetIcon(item->m_strPath);
+                if (!strImage.IsEmpty() && g_TextureManager.HasTexture(strImage))
+                    item->SetIconImage(strImage);
+            }
+        }
+
+        return bResult;
+    }
 }
 
 NODE_TYPE CMusicDatabaseDirectory::GetDirectoryChildType(const CStdString& strPath)
 {
-  auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
+    auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
 
-  if (!pNode.get())
-    return NODE_TYPE_NONE;
+    //spotify, we need to force artist views
+   // CLog::Log( LOGERROR, "Spotifylog: force artist %s, ", strPath.c_str());
+    if (strPath.Left(34) == "musicdb://1/spotifyartist/artists/" || strPath.Left(26) == "musicdb://1/spotifyartist/")
+    {
+        return NODE_TYPE_ARTIST;
+    }
 
-  return pNode->GetChildType();
+
+    if (!pNode.get())
+        return NODE_TYPE_NONE;
+
+    return pNode->GetChildType();
 }
 
 NODE_TYPE CMusicDatabaseDirectory::GetDirectoryType(const CStdString& strPath)
 {
-  auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
 
-  if (!pNode.get())
-    return NODE_TYPE_NONE;
+    auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
 
-  return pNode->GetType();
+    if (!pNode.get())
+        return NODE_TYPE_NONE;
+
+    return pNode->GetType();
 }
 
 NODE_TYPE CMusicDatabaseDirectory::GetDirectoryParentType(const CStdString& strPath)
 {
-  auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
+    auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
 
-  if (!pNode.get())
-    return NODE_TYPE_NONE;
+    if (!pNode.get())
+        return NODE_TYPE_NONE;
 
-  CDirectoryNode* pParentNode=pNode->GetParent();
+    CDirectoryNode* pParentNode=pNode->GetParent();
 
-  if (!pParentNode)
-    return NODE_TYPE_NONE;
+    if (!pParentNode)
+        return NODE_TYPE_NONE;
 
-  return pParentNode->GetChildType();
+    return pParentNode->GetChildType();
 }
 
 bool CMusicDatabaseDirectory::IsArtistDir(const CStdString& strDirectory)
 {
-  NODE_TYPE node=GetDirectoryType(strDirectory);
-  return (node==NODE_TYPE_ARTIST);
+    NODE_TYPE node=GetDirectoryType(strDirectory);
+    return (node==NODE_TYPE_ARTIST);
 }
 
 bool CMusicDatabaseDirectory::HasAlbumInfo(const CStdString& strDirectory)
 {
-  NODE_TYPE node=GetDirectoryType(strDirectory);
-  return (node!=NODE_TYPE_OVERVIEW && node!=NODE_TYPE_TOP100 &&
-          node!=NODE_TYPE_GENRE && node!=NODE_TYPE_ARTIST && node!=NODE_TYPE_YEAR);
+    NODE_TYPE node=GetDirectoryType(strDirectory);
+    return (node!=NODE_TYPE_OVERVIEW && node!=NODE_TYPE_TOP100 &&
+            node!=NODE_TYPE_GENRE && node!=NODE_TYPE_ARTIST && node!=NODE_TYPE_YEAR);
 }
 
 void CMusicDatabaseDirectory::ClearDirectoryCache(const CStdString& strDirectory)
 {
-  CFileItem directory(strDirectory, true);
-  CUtil::RemoveSlashAtEnd(directory.m_strPath);
+    CFileItem directory(strDirectory, true);
+    CUtil::RemoveSlashAtEnd(directory.m_strPath);
 
-  Crc32 crc;
-  crc.ComputeFromLowerCase(directory.m_strPath);
+    Crc32 crc;
+    crc.ComputeFromLowerCase(directory.m_strPath);
 
-  CStdString strFileName;
-  strFileName.Format("special://temp/%08x.fi", (unsigned __int32) crc);
-  CFile::Delete(strFileName);
+    CStdString strFileName;
+    strFileName.Format("special://temp/%08x.fi", (unsigned __int32) crc);
+    CFile::Delete(strFileName);
 }
 
 bool CMusicDatabaseDirectory::IsAllItem(const CStdString& strDirectory)
 {
-  if (strDirectory.Right(4).Equals("/-1/"))
-    return true;
-  return false;
+    if (strDirectory.Right(4).Equals("/-1/"))
+        return true;
+    return false;
 }
 
 bool CMusicDatabaseDirectory::GetLabel(const CStdString& strDirectory, CStdString& strLabel)
 {
-  strLabel = "";
+    strLabel = "";
 
-  auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strDirectory));
-  if (!pNode.get())
-    return false;
+    auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strDirectory));
+    if (!pNode.get())
+        return false;
 
-  // first see if there's any filter criteria
-  CQueryParams params;
-  CDirectoryNode::GetDatabaseInfo(strDirectory, params);
+    // first see if there's any filter criteria
+    CQueryParams params;
+    CDirectoryNode::GetDatabaseInfo(strDirectory, params);
 
-  CMusicDatabase musicdatabase;
-  if (!musicdatabase.Open())
-    return false;
+    CMusicDatabase musicdatabase;
+    if (!musicdatabase.Open())
+        return false;
 
-  // get genre
-  CStdString strTemp;
-  if (params.GetGenreId() >= 0)
-  {
-    strTemp = "";
-    musicdatabase.GetGenreById(params.GetGenreId(), strTemp);
-    strLabel += strTemp;
-  }
+    // get genre
+    CStdString strTemp;
+    if (params.GetGenreId() >= 0)
+    {
+        strTemp = "";
+        musicdatabase.GetGenreById(params.GetGenreId(), strTemp);
+        strLabel += strTemp;
+    }
 
-  // get artist
-  if (params.GetArtistId() >= 0)
-  {
-    strTemp = "";
-    musicdatabase.GetArtistById(params.GetArtistId(), strTemp);
-    if (!strLabel.IsEmpty())
-      strLabel += " / ";
-    strLabel += strTemp;
-  }
+    // get artist
+    if (params.GetArtistId() >= 0)
+    {
+        strTemp = "";
+        musicdatabase.GetArtistById(params.GetArtistId(), strTemp);
+        if (!strLabel.IsEmpty())
+            strLabel += " / ";
+        strLabel += strTemp;
+    }
 
-  // get album
-  if (params.GetAlbumId() >= 0)
-  {
-    strTemp = "";
-    musicdatabase.GetAlbumById(params.GetAlbumId(), strTemp);
-    if (!strLabel.IsEmpty())
-      strLabel += " / ";
-    strLabel += strTemp;
-  }
+    // get album
+    if (params.GetAlbumId() >= 0)
+    {
+        strTemp = "";
+        musicdatabase.GetAlbumById(params.GetAlbumId(), strTemp);
+        if (!strLabel.IsEmpty())
+            strLabel += " / ";
+        strLabel += strTemp;
+    }
 
-  if (strLabel.IsEmpty())
-  {
-    switch (pNode->GetChildType())
+    if (strLabel.IsEmpty())
     {
-    case NODE_TYPE_TOP100:
-      strLabel = g_localizeStrings.Get(271); // Top 100
-      break;
-    case NODE_TYPE_GENRE:
-      strLabel = g_localizeStrings.Get(135); // Genres
-      break;
-    case NODE_TYPE_ARTIST:
-      strLabel = g_localizeStrings.Get(133); // Artists
-      break;
-    case NODE_TYPE_ALBUM:
-      strLabel = g_localizeStrings.Get(132); // Albums
-      break;
-    case NODE_TYPE_ALBUM_RECENTLY_ADDED:
-    case NODE_TYPE_ALBUM_RECENTLY_ADDED_SONGS:
-      strLabel = g_localizeStrings.Get(359); // Recently Added Albums
-      break;
-    case NODE_TYPE_ALBUM_RECENTLY_PLAYED:
-    case NODE_TYPE_ALBUM_RECENTLY_PLAYED_SONGS:
-      strLabel = g_localizeStrings.Get(517); // Recently Played Albums
-      break;
-    case NODE_TYPE_ALBUM_TOP100:
-    case NODE_TYPE_ALBUM_TOP100_SONGS:
-      strLabel = g_localizeStrings.Get(10505); // Top 100 Albums
-      break;
-    case NODE_TYPE_SINGLES:
-      strLabel = g_localizeStrings.Get(1050); // Singles
-      break;
-    case NODE_TYPE_SONG:
-      strLabel = g_localizeStrings.Get(134); // Songs
-      break;
-    case NODE_TYPE_SONG_TOP100:
-      strLabel = g_localizeStrings.Get(10504); // Top 100 Songs
-      break;
-    case NODE_TYPE_YEAR:
-    case NODE_TYPE_YEAR_ALBUM:
-    case NODE_TYPE_YEAR_SONG:
-      strLabel = g_localizeStrings.Get(652);  // Years
-      break;
-    case NODE_TYPE_ALBUM_COMPILATIONS:
-    case NODE_TYPE_ALBUM_COMPILATIONS_SONGS:
-      strLabel = g_localizeStrings.Get(521);
-      break;
-    case NODE_TYPE_OVERVIEW:
-      strLabel = "";
-      break;
-    default:
-      CLog::Log(LOGWARNING, "%s - Unknown nodetype requested %d", __FUNCTION__, pNode->GetChildType());
-      return false;
+        switch (pNode->GetChildType())
+        {
+        case NODE_TYPE_TOP100:
+            strLabel = g_localizeStrings.Get(271); // Top 100
+            break;
+        case NODE_TYPE_GENRE:
+            strLabel = g_localizeStrings.Get(135); // Genres
+            break;
+        case NODE_TYPE_ARTIST:
+            strLabel = g_localizeStrings.Get(133); // Artists
+            break;
+        case NODE_TYPE_ALBUM:
+            strLabel = g_localizeStrings.Get(132); // Albums
+            break;
+        case NODE_TYPE_ALBUM_RECENTLY_ADDED:
+        case NODE_TYPE_ALBUM_RECENTLY_ADDED_SONGS:
+            strLabel = g_localizeStrings.Get(359); // Recently Added Albums
+            break;
+        case NODE_TYPE_ALBUM_RECENTLY_PLAYED:
+        case NODE_TYPE_ALBUM_RECENTLY_PLAYED_SONGS:
+            strLabel = g_localizeStrings.Get(517); // Recently Played Albums
+            break;
+        case NODE_TYPE_ALBUM_TOP100:
+        case NODE_TYPE_ALBUM_TOP100_SONGS:
+            strLabel = g_localizeStrings.Get(10505); // Top 100 Albums
+            break;
+        case NODE_TYPE_SINGLES:
+            strLabel = g_localizeStrings.Get(1050); // Singles
+            break;
+        case NODE_TYPE_SONG:
+            strLabel = g_localizeStrings.Get(134); // Songs
+            break;
+        case NODE_TYPE_SONG_TOP100:
+            strLabel = g_localizeStrings.Get(10504); // Top 100 Songs
+            break;
+        case NODE_TYPE_YEAR:
+        case NODE_TYPE_YEAR_ALBUM:
+        case NODE_TYPE_YEAR_SONG:
+            strLabel = g_localizeStrings.Get(652);  // Years
+            break;
+        case NODE_TYPE_ALBUM_COMPILATIONS:
+        case NODE_TYPE_ALBUM_COMPILATIONS_SONGS:
+            strLabel = g_localizeStrings.Get(521);
+            break;
+        case NODE_TYPE_OVERVIEW:
+            strLabel = "";
+            break;
+        default:
+            CLog::Log(LOGWARNING, "%s - Unknown nodetype requested %d", __FUNCTION__, pNode->GetChildType());
+            return false;
+        }
     }
-  }
 
-  return true;
+    return true;
 }
 
 bool CMusicDatabaseDirectory::ContainsSongs(const CStdString &path)
 {
-  MUSICDATABASEDIRECTORY::NODE_TYPE type = GetDirectoryChildType(path);
-  if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_SONG) return true;
-  if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_SINGLES) return true;
-  if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_ALBUM_RECENTLY_ADDED_SONGS) return true;
-  if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_ALBUM_RECENTLY_PLAYED_SONGS) return true;
-  if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_ALBUM_COMPILATIONS_SONGS) return true;
-  if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_ALBUM_TOP100_SONGS) return true;
-  if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_SONG_TOP100) return true;
-  if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_YEAR_SONG) return true;
-  return false;
+    MUSICDATABASEDIRECTORY::NODE_TYPE type = GetDirectoryChildType(path);
+    if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_SONG) return true;
+    if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_SINGLES) return true;
+    if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_ALBUM_RECENTLY_ADDED_SONGS) return true;
+    if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_ALBUM_RECENTLY_PLAYED_SONGS) return true;
+    if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_ALBUM_COMPILATIONS_SONGS) return true;
+    if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_ALBUM_TOP100_SONGS) return true;
+    if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_SONG_TOP100) return true;
+    if (type == MUSICDATABASEDIRECTORY::NODE_TYPE_YEAR_SONG) return true;
+    return false;
 }
 
 bool CMusicDatabaseDirectory::Exists(const char* strPath)
 {
-  auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
+    auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
 
-  if (!pNode.get())
-    return false;
+    if (!pNode.get())
+        return false;
 
-  if (pNode->GetChildType() == MUSICDATABASEDIRECTORY::NODE_TYPE_NONE)
-    return false;
+    if (pNode->GetChildType() == MUSICDATABASEDIRECTORY::NODE_TYPE_NONE)
+        return false;
 
-  return true;
+    return true;
 }
 
 bool CMusicDatabaseDirectory::CanCache(const CStdString& strPath)
 {
-  auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
-  if (!pNode.get())
-    return false;
-  return pNode->CanCache();
+    auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
+    if (!pNode.get())
+        return false;
+    return pNode->CanCache();
 }
 
 CStdString CMusicDatabaseDirectory::GetIcon(const CStdString &strDirectory)
 {
-  switch (GetDirectoryChildType(strDirectory))
-  {
-  case NODE_TYPE_ARTIST:
-      return "DefaultMusicArtists.png";
-  case NODE_TYPE_GENRE:
-      return "DefaultMusicGenres.png";
-  case NODE_TYPE_TOP100:
-      return "DefaultMusicTop100.png";
-  case NODE_TYPE_ALBUM:
-  case NODE_TYPE_YEAR_ALBUM:
-    return "DefaultMusicAlbums.png";
-  case NODE_TYPE_ALBUM_RECENTLY_ADDED:
-  case NODE_TYPE_ALBUM_RECENTLY_ADDED_SONGS:
-    return "DefaultMusicRecentlyAdded.png";
-  case NODE_TYPE_ALBUM_RECENTLY_PLAYED:
-  case NODE_TYPE_ALBUM_RECENTLY_PLAYED_SONGS:
-    return "DefaultMusicRecentlyPlayed.png";
-  case NODE_TYPE_SINGLES:
-  case NODE_TYPE_SONG:
-  case NODE_TYPE_YEAR_SONG:
-  case NODE_TYPE_ALBUM_COMPILATIONS_SONGS:
-    return "DefaultMusicSongs.png";
-  case NODE_TYPE_ALBUM_TOP100:
-  case NODE_TYPE_ALBUM_TOP100_SONGS:
-    return "DefaultMusicTop100Albums.png";
-  case NODE_TYPE_SONG_TOP100:
-    return "DefaultMusicTop100Songs.png";
-  case NODE_TYPE_YEAR:
-    return "DefaultMusicYears.png";
-  case NODE_TYPE_ALBUM_COMPILATIONS:
-    return "DefaultMusicCompilations.png";
-  default:
-    CLog::Log(LOGWARNING, "%s - Unknown nodetype requested %s", __FUNCTION__, strDirectory.c_str());
-    break;
-  }
+    switch (GetDirectoryChildType(strDirectory))
+    {
+    case NODE_TYPE_ARTIST:
+        return "DefaultMusicArtists.png";
+    case NODE_TYPE_GENRE:
+        return "DefaultMusicGenres.png";
+    case NODE_TYPE_TOP100:
+        return "DefaultMusicTop100.png";
+    case NODE_TYPE_ALBUM:
+    case NODE_TYPE_YEAR_ALBUM:
+        return "DefaultMusicAlbums.png";
+    case NODE_TYPE_ALBUM_RECENTLY_ADDED:
+    case NODE_TYPE_ALBUM_RECENTLY_ADDED_SONGS:
+        return "DefaultMusicRecentlyAdded.png";
+    case NODE_TYPE_ALBUM_RECENTLY_PLAYED:
+    case NODE_TYPE_ALBUM_RECENTLY_PLAYED_SONGS:
+        return "DefaultMusicRecentlyPlayed.png";
+    case NODE_TYPE_SINGLES:
+    case NODE_TYPE_SONG:
+    case NODE_TYPE_YEAR_SONG:
+    case NODE_TYPE_ALBUM_COMPILATIONS_SONGS:
+        return "DefaultMusicSongs.png";
+    case NODE_TYPE_ALBUM_TOP100:
+    case NODE_TYPE_ALBUM_TOP100_SONGS:
+        return "DefaultMusicTop100Albums.png";
+    case NODE_TYPE_SONG_TOP100:
+        return "DefaultMusicTop100Songs.png";
+    case NODE_TYPE_YEAR:
+        return "DefaultMusicYears.png";
+    case NODE_TYPE_ALBUM_COMPILATIONS:
+        return "DefaultMusicCompilations.png";
+    default:
+        CLog::Log(LOGWARNING, "%s - Unknown nodetype requested %s", __FUNCTION__, strDirectory.c_str());
+        break;
+    }
 
-  return "";
+    return "";
 }
 
Index: xbmc/MusicDatabase.cpp
===================================================================
--- xbmc/MusicDatabase.cpp	(revision 27356)
+++ xbmc/MusicDatabase.cpp	(working copy)
@@ -1575,6 +1575,33 @@
   return false;
 }
 
+//spotify
+bool CMusicDatabase::RemoveAlbum(CStdString albumPath)
+{
+    albumPath.Delete(0,12);
+    CUtil::RemoveSlashAtEnd(albumPath);
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    CStdString strSQL;
+    strSQL=FormatSQL("delete from song where idAlbum=%s", albumPath.c_str());
+    m_pDS->exec(strSQL.c_str());
+    strSQL=FormatSQL("delete from album where idAlbum=%s", albumPath.c_str());
+    m_pDS->exec(strSQL.c_str());
+    this->CleanupSongs();
+    this->CleanupAlbums();
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+  }
+
+  return false;
+}
+
 void CMusicDatabase::EmptyCache()
 {
   m_artistCache.erase(m_artistCache.begin(), m_artistCache.end());
@@ -1851,7 +1878,8 @@
         CUtil::RemoveSlashAtEnd(strFileName);
       }
 
-      if (!CFile::Exists(strFileName))
+      //spotify, dont delete it if its a spotify song
+      if (CUtil::GetExtension(strFileName) !=".spotify" && !CFile::Exists(strFileName))
       { // file no longer exists, so add to deletion list
         strSongsToDelete += m_pDS->fv("song.idSong").get_asString() + ",";
       }
Index: xbmc/Makefile.in
===================================================================
--- xbmc/Makefile.in	(revision 27356)
+++ xbmc/Makefile.in	(working copy)
@@ -10,11 +10,12 @@
           -Ilib/libUPnP/Platinum/Source/Devices/MediaConnect \
           -Ilib/libUPnP/Platinum/Source/Devices/MediaRenderer \
           -Ilib/libUPnP/Neptune/Source/System/Posix \
-          -Ilib/libUPnP/Neptune/Source/Core
+          -Ilib/libUPnP/Neptune/Source/Core \
 
 INCLUDES+=-Ilib/libcdio/libcdio/include
 
-SRCS=Application.cpp \
+SRCS=spotinterface.cpp \
+     Application.cpp \
      CueDocument.cpp \
      GUISettings.cpp \
      GUIWindowSettings.cpp \
Index: xbmc/GUIViewStateMusic.cpp
===================================================================
--- xbmc/GUIViewStateMusic.cpp	(revision 27356)
+++ xbmc/GUIViewStateMusic.cpp	(working copy)
@@ -100,7 +100,15 @@
 {
   SaveViewToDb(m_items.m_strPath, WINDOW_MUSIC_NAV, &g_settings.m_viewStateMusicNavSongs);
 }
+//spotify, why? well by doing this we make sure that its impossible to change the order the menu items are displayed
+CGUIViewStateSpotifyLibrary::CGUIViewStateSpotifyLibrary(const CFileItemList& items) : CGUIViewStateWindowMusic(items)
+{
+}
 
+void CGUIViewStateSpotifyLibrary::SaveViewState()
+{
+}
+
 CGUIViewStateMusicDatabase::CGUIViewStateMusicDatabase(const CFileItemList& items) : CGUIViewStateWindowMusic(items)
 {
   CMusicDatabaseDirectory dir;
@@ -509,6 +517,17 @@
 
 void CGUIViewStateWindowMusicNav::AddOnlineShares()
 {
+  //spotify, only if we do use spotify
+  CLog::Log(LOGDEBUG,"Adding spotify share");
+  if (g_advancedSettings.m_spotifyEnable)
+  {
+      CMediaSource share;
+      share.strName="Spotify"; // main menu
+      share.strPath = "spotify://menu";
+      share.m_strThumbnailImage = CUtil::GetDefaultFolderThumb("special://xbmc/media/spotify_core_logo.png");
+      share.m_iDriveType = CMediaSource::SOURCE_TYPE_LOCAL;
+      m_sources.push_back(share);
+  }
   if (!g_advancedSettings.m_bVirtualShares) return;
   for (int i = 0; i < (int)g_settings.m_musicSources.size(); ++i)
   {
Index: xbmc/GUIDialogContextMenu.h
===================================================================
--- xbmc/GUIDialogContextMenu.h	(revision 27356)
+++ xbmc/GUIDialogContextMenu.h	(working copy)
@@ -112,7 +112,9 @@
                       CONTEXT_BUTTON_USER7,
                       CONTEXT_BUTTON_USER8,
                       CONTEXT_BUTTON_USER9,
-                      CONTEXT_BUTTON_USER10
+                      CONTEXT_BUTTON_USER10,
+                      //spotify add a button for removing albums from lib
+                      CONTEXT_BUTTON_SPOTIFY_REMOVE_ALBUM
                     };
 
 class CContextButtons : public std::vector< std::pair<CONTEXT_BUTTON, CStdString> >
Index: xbmc/GUIWindowMusicNav.cpp
===================================================================
--- xbmc/GUIWindowMusicNav.cpp	(revision 27356)
+++ xbmc/GUIWindowMusicNav.cpp	(working copy)
@@ -174,6 +174,10 @@
       }
 
       //  base class has opened the database, do our check
+      //spotify  we still want a library view if we have spotify enabled
+      if (g_advancedSettings.m_spotifyEnable)
+        return true;
+
       DisplayEmptyDatabaseMessage(m_musicdatabase.GetSongsCount() <= 0);
 
       if (m_bDisplayEmptyDatabaseMessage)
@@ -603,6 +607,14 @@
       if (strcmp(g_settings.m_defaultMusicLibSource, ""))
         buttons.Add(CONTEXT_BUTTON_CLEAR_DEFAULT, 13403); // clear default
     }
+    
+    CLog::Log(LOGERROR, "spotifylog: lägger till knapp, contenttype: %s",m_vecItems->GetContentType().c_str() );
+    if (!item->IsParentFolder() && nodetype == NODE_TYPE_ALBUM && m_vecItems->GetContentType() == "spotifyalbum");
+    {
+      //spotify add the remove album button
+      buttons.Add(CONTEXT_BUTTON_SPOTIFY_REMOVE_ALBUM,"Remove album");
+    }
+    
     NODE_TYPE childtype = dir.GetDirectoryChildType(item->m_strPath);
     if (childtype == NODE_TYPE_ALBUM               ||
         childtype == NODE_TYPE_ARTIST              ||
@@ -666,9 +678,21 @@
   CFileItemPtr item;
   if (itemNumber >= 0 && itemNumber < m_vecItems->Size())
     item = m_vecItems->Get(itemNumber);
+  CSongMap songMap;
+  CMusicDatabase db;
 
   switch (button)
   {
+    //spotify remove the album
+  case CONTEXT_BUTTON_SPOTIFY_REMOVE_ALBUM:
+        CLog::Log(LOGERROR, "spotifylog: försöker ta bort %s", item->m_strPath.c_str());
+        db.Open();
+        db.BeginTransaction();
+        db.RemoveAlbum(item->m_strPath);
+        db.CommitTransaction();
+        db.Close();
+        Update(m_history.GetParentPath());
+        return true;
   case CONTEXT_BUTTON_INFO:
     {
       if (!item->IsVideoDb())
Index: xbmc/AdvancedSettings.h
===================================================================
--- xbmc/AdvancedSettings.h	(revision 27356)
+++ xbmc/AdvancedSettings.h	(working copy)
@@ -61,6 +61,17 @@
     CStdString m_audioDefaultPlayer;
     float m_audioPlayCountMinimumPercent;
 
+    //Spotify
+    bool m_spotifyEnable;
+    bool m_spotifyUseHighBitrate;
+    CStdString m_spotifyUsername;
+    CStdString m_spotifyPassword;
+    CStdString m_spotifyCacheFolder;
+    int m_spotifyMaxSearchArtists;
+    int m_spotifyMaxSearchAlbums;
+    int m_spotifyMaxSearchTracks;
+
+
     float m_videoSubsDelayRange;
     float m_videoAudioDelayRange;
     int m_videoSmallStepBackSeconds;
Index: xbmc/Settings.cpp
===================================================================
--- xbmc/Settings.cpp	(revision 27356)
+++ xbmc/Settings.cpp	(working copy)
@@ -104,7 +104,8 @@
   m_fPixelRatio = 1.0f;
 
   m_pictureExtensions = ".png|.jpg|.jpeg|.bmp|.gif|.ico|.tif|.tiff|.tga|.pcx|.cbz|.zip|.cbr|.rar|.m3u|.dng|.nef|.cr2|.crw|.orf|.arw|.erf|.3fr|.dcr|.x3f|.mef|.raf|.mrw|.pef|.sr2|.rss";
-  m_musicExtensions = ".nsv|.m4a|.flac|.aac|.strm|.pls|.rm|.rma|.mpa|.wav|.wma|.ogg|.mp3|.mp2|.m3u|.mod|.amf|.669|.dmf|.dsm|.far|.gdm|.imf|.it|.m15|.med|.okt|.s3m|.stm|.sfx|.ult|.uni|.xm|.sid|.ac3|.dts|.cue|.aif|.aiff|.wpl|.ape|.mac|.mpc|.mp+|.mpp|.shn|.zip|.rar|.wv|.nsf|.spc|.gym.adx|.dsp|.adp|.ymf|.ast|.afc|.hps|.xsp|.xwav|.waa|.wvs|.wam|.gcm|.idsp|.mpdsp|.mss|.spt|.rsd|.mid|.kar|.sap|.cmc|.cmr|.dmc|.mpt|.mpd|.rmt|.tmc|.tm8|.tm2|.oga|.url|.pxml|.tta|.rss|.cm3|.cms|.dlt";
+    //spotify, enables us to remove the .spotify extension
+  m_musicExtensions = ".spotify|.nsv|.m4a|.flac|.aac|.strm|.pls|.rm|.rma|.mpa|.wav|.wma|.ogg|.mp3|.mp2|.m3u|.mod|.amf|.669|.dmf|.dsm|.far|.gdm|.imf|.it|.m15|.med|.okt|.s3m|.stm|.sfx|.ult|.uni|.xm|.sid|.ac3|.dts|.cue|.aif|.aiff|.wpl|.ape|.mac|.mpc|.mp+|.mpp|.shn|.zip|.rar|.wv|.nsf|.spc|.gym.adx|.dsp|.adp|.ymf|.ast|.afc|.hps|.xsp|.xwav|.waa|.wvs|.wam|.gcm|.idsp|.mpdsp|.mss|.spt|.rsd|.mid|.kar|.sap|.cmc|.cmr|.dmc|.mpt|.mpd|.rmt|.tmc|.tm8|.tm2|.oga|.url|.pxml|.tta|.rss|.cm3|.cms|.dlt";
   m_videoExtensions = ".m4v|.3g2|.3gp|.nsv|.tp|.ts|.ty|.strm|.pls|.rm|.rmvb|.m3u|.ifo|.mov|.qt|.divx|.xvid|.bivx|.vob|.nrg|.img|.iso|.pva|.wmv|.asf|.asx|.ogm|.m2v|.avi|.bin|.dat|.mpg|.mpeg|.mp4|.mkv|.avc|.vp3|.svq3|.nuv|.viv|.dv|.fli|.flv|.rar|.001|.wpl|.zip|.vdr|.dvr-ms|.xsp|.mts|.m2t|.m2ts|.evo|.ogv|.sdp|.avs|.rec|.url|.pxml|.vc1|.h264|.rcv|.rss|.mpls";
   // internal music extensions
   m_musicExtensions += "|.sidstream|.oggstream|.nsfstream|.asapstream|.cdda";
Index: xbmc/GUIMediaWindow.cpp
===================================================================
--- xbmc/GUIMediaWindow.cpp	(revision 27356)
+++ xbmc/GUIMediaWindow.cpp	(working copy)
@@ -52,6 +52,8 @@
 #include "utils/TimeUtils.h"
 #include "FactoryFileDirectory.h"
 #include "utils/log.h"
+//spotify
+#include "spotinterface.h"
 #include "utils/FileUtils.h"
 
 #define CONTROL_BTNVIEWASICONS     2
Index: xbmc/GUIViewStateMusic.h
===================================================================
--- xbmc/GUIViewStateMusic.h	(revision 27356)
+++ xbmc/GUIViewStateMusic.h	(working copy)
@@ -71,6 +71,16 @@
   virtual void SaveViewState();
 };
 
+//spotify
+class CGUIViewStateSpotifyLibrary : public CGUIViewStateWindowMusic
+{
+public:
+  CGUIViewStateSpotifyLibrary(const CFileItemList& items);
+
+protected:
+  virtual void SaveViewState();
+};
+
 class CGUIViewStateWindowMusicNav : public CGUIViewStateWindowMusic
 {
 public:
